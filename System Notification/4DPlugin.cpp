/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : System Notification
 #	author : miyako
 #	2016/04/15
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#pragma mark -

namespace SN {

	process_name_t MONITOR_PROCESS_NAME = (PA_Unichar *)"$\0S\0L\0E\0E\0P\0_\0N\0O\0T\0I\0F\0I\0C\0A\0T\0I\0O\0N\0\0\0";
	process_number_t MONITOR_PROCESS_ID = 0;
	process_stack_size_t MONITOR_PROCESS_STACK_SIZE = 0;
	method_id_t CALLBACK_METHOD_ID = 0;
	event_id_t CALLBACK_EVENT_ID = 0;
	C_TEXT LISTENER_METHOD;
	bool MONITOR_PROCESS_SHOULD_TERMINATE;
	std::vector<event_id_t>CALLBACK_EVENT_IDS;
	bool termination_not_allowed = false;

#if VERSIONMAC
	Listener *listener = nil;
#else
	HWND windowRef = NULL;
	WNDPROC originalWndProc = NULL;
	HPOWERNOTIFY notificationHandle = NULL;
	bool first_event_call = false;

	void call(event_id_t event)
	{
		SN::CALLBACK_EVENT_ID = event;
		SN::CALLBACK_EVENT_IDS.push_back(SN::CALLBACK_EVENT_ID);
		listenerLoopExecute();
	}
	
	HWND getHWND()
	{
		//the window class is the folder name of the application
		HWND mdi = NULL;
		wchar_t path[_MAX_PATH] = {0};
		wchar_t * applicationPath = wcscpy(path, (const wchar_t *)PA_GetApplicationFullPath().fString);
		//remove file name (4D.exe)
		PathRemoveFileSpec(path);
		//check instance as well, to be sure
		HINSTANCE h = (HINSTANCE)PA_Get4DHInstance();
		do {
			mdi = FindWindowEx(NULL, mdi, (LPCTSTR)path, NULL);
			if (mdi)
			{
				if (h == (HINSTANCE)GetWindowLongPtr(mdi, GWLP_HINSTANCE))
				{
					break;
				}
			}
		} while (mdi);
		
		return mdi;
	}
	
	LRESULT CALLBACK customWndProc(HWND wnd, UINT msg, WPARAM wp, LPARAM lp){
		
		POWERBROADCAST_SETTING *pbs = (POWERBROADCAST_SETTING *)lp;
		
		switch (msg) {
			case WM_QUERYENDSESSION:
				SN::call(3);
				return false;//refuse to quit
				break;
			case WM_POWERBROADCAST:
				switch (wp) {
					case PBT_APMRESUMEAUTOMATIC://resume
						SN::call(1);
						break;
					case PBT_APMSUSPEND://suspend
						SN::call(2);
						break;
						
					case PBT_POWERSETTINGCHANGE:
						if(pbs->PowerSetting == GUID_MONITOR_POWER_ON)
						{
							if(SN::first_event_call){
								SN::first_event_call = false;
							}else{
							DWORD state = *((DWORD*)pbs->Data);
							switch (state)
							{
							case 0:
								SN::call(5);//screen off
								break;
							case 1:
								SN::call(4);//screen on
								break;
							}							
							}
						}
						break;
					default:
						break;
				}
				break;
			default:
				break;
		}
		
		return CallWindowProc(SN::originalWndProc, wnd, msg, wp, lp);
	}
	
#endif
	
}

#if VERSIONMAC

#if CGFLOAT_IS_DOUBLE
static IMP __orig_imp_applicationShouldTerminate;

NSApplicationTerminateReply __swiz_applicationShouldTerminate(id self, SEL _cmd, id sender) {
    
	[SN::listener call:6];
	
	return NSTerminateCancel;//refuse to quit
}

IMP __swiz_imp_applicationShouldTerminate = (IMP)__swiz_applicationShouldTerminate;
#else
AEEventHandlerUPP __upp_applicationShouldTerminate;
OSErr carbon_applicationShouldTerminate(const AppleEvent *appleEvt, AppleEvent* reply, UInt32 refcon) {
    
	[SN::listener call:6];
	
	return noErr;
}

static pascal OSErr HandleQuitMessage(const AppleEvent *appleEvt, AppleEvent *reply, long refcon) {
    
	return userCanceledErr;
}
#endif

@implementation Listener

- (id)init {
    
	if(!(self = [super init])) return self;
	
	NSNotificationCenter *center = [[NSWorkspace sharedWorkspace]notificationCenter];
	
	[center
	 addObserver:self
	 selector: @selector(willSleep:)
	 name:NSWorkspaceWillSleepNotification
	 object:nil];
	
	[center
	 addObserver:self
	 selector: @selector(didWake:)
	 name:NSWorkspaceDidWakeNotification
	 object:nil];
	
	[center
	 addObserver:self
	 selector: @selector(screensDidSleep:)
	 name:NSWorkspaceScreensDidSleepNotification
	 object:nil];
	
	[center
	 addObserver:self
	 selector: @selector(screensDidWake:)
	 name:NSWorkspaceScreensDidWakeNotification
	 object:nil];
	
	[center
	 addObserver:self
	 selector: @selector(willPowerOff:)
	 name:NSWorkspaceWillPowerOffNotification
	 object:nil];
	
	/* swizzle */
#if CGFLOAT_IS_DOUBLE
	Class MainAppDelegateClass = [[[NSApplication sharedApplication]delegate]class];
	
	if(MainAppDelegateClass)
	{
		__orig_imp_applicationShouldTerminate =
		method_setImplementation(
														 class_getInstanceMethod(MainAppDelegateClass,
																										 @selector(applicationShouldTerminate:)),
														 __swiz_imp_applicationShouldTerminate);
	}
#else
	__upp_applicationShouldTerminate = NewAEEventHandlerUPP(HandleQuitMessage);
	AEInstallEventHandler(kCoreEventClass,
												kAEQuitApplication,
												__upp_applicationShouldTerminate, 0, false);
#endif

	return self;
}

- (void)dealloc {
    
	/* swizzle */
#if CGFLOAT_IS_DOUBLE
	Class MainAppDelegateClass = [[[NSApplication sharedApplication]delegate]class];
	
	if(MainAppDelegateClass)
	{
		method_setImplementation(
														 class_getInstanceMethod(MainAppDelegateClass, @selector(applicationShouldTerminate:)),
														 __orig_imp_applicationShouldTerminate);
	}
#else
	AERemoveEventHandler(kCoreEventClass,
											 kAEQuitApplication,
											 __upp_applicationShouldTerminate,
											 false);
	DisposeAEEventHandlerUPP(__upp_applicationShouldTerminate);
#endif
	
	[[[NSWorkspace sharedWorkspace] notificationCenter]removeObserver:self];
	
	[super dealloc];
}

- (void)didWake:(NSNotification *)notification {
    
	[self call:1];
}

- (void)willSleep:(NSNotification *)notification {
    
	[self call:2];
}

- (void)willPowerOff:(NSNotification *)notification {
    
	[self call:3];
}

- (void)screensDidWake:(NSNotification *)notification {
    
	[self call:4];
}

- (void)screensDidSleep:(NSNotification *)notification {
    
	[self call:5];
}

- (void)call:(event_id_t)event {
    
	SN::CALLBACK_EVENT_ID = event;
	SN::CALLBACK_EVENT_IDS.push_back(SN::CALLBACK_EVENT_ID);
	listenerLoopExecute();
}

@end

#endif

#pragma mark -

void generateUuid(C_TEXT &returnValue) {
    
#if VERSIONMAC
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
	returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
	CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
	NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
	returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
#else
	RPC_WSTR str;
	UUID uuid;
	int len;
	wchar_t *buffer;
	if(UuidCreate(&uuid) == RPC_S_OK){
		if(UuidToString(&uuid, &str)==RPC_S_OK){
			len = (wcslen((const wchar_t *)str)*2)+2;
			buffer = (wchar_t *)malloc(len);if(buffer){
				memset(buffer,0x00, len);
				memcpy(buffer, str, len);
				_wcsupr((wchar_t *)buffer);
				CUTF16String uid = (const PA_Unichar *)buffer;
				returnValue.setUTF16String(&uid);
				free(buffer);
			}
			RpcStringFree(&str);
		}
	}
#endif
}

#pragma mark -

bool IsProcessOnExit() {
    
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnStartup() {
    
#if VERSIONMAC

#else
	SN::windowRef = SN::getHWND();
#endif
}

void OnExit() {
    
    listenerLoopFinish();
}

void OnCloseProcess() {
    
	if(IsProcessOnExit())
	{
		OnExit();
	}
}

#pragma mark -

void listenerLoop() {
    
	SN::MONITOR_PROCESS_SHOULD_TERMINATE = false;

#if VERSIONMAC
	SN::listener = [[Listener alloc]init];
#else
	SN::first_event_call = true;
	SN::notificationHandle = RegisterPowerSettingNotification(
																														SN::windowRef, &GUID_MONITOR_POWER_ON,
																														DEVICE_NOTIFY_WINDOW_HANDLE);
	
	SN::originalWndProc = (WNDPROC)GetWindowLongPtr(SN::windowRef, GWLP_WNDPROC);
	SetWindowLongPtr(SN::windowRef, GWLP_WNDPROC, (LONG_PTR)SN::customWndProc);
#endif
	
	while(!SN::MONITOR_PROCESS_SHOULD_TERMINATE)
	{
		PA_YieldAbsolute();
		
		while(SN::CALLBACK_EVENT_IDS.size())
		{
			PA_YieldAbsolute();
			
			listenerLoopExecuteMethod();
			
			/*
			 C_TEXT processName;
			 generateUuid(processName);
			 PA_NewProcess((void *)listenerLoopExecute,
			 SN::MONITOR_PROCESS_STACK_SIZE,
			 (PA_Unichar *)processName.getUTF16StringPtr());
			 */

			if(SN::MONITOR_PROCESS_SHOULD_TERMINATE)
				break;
		}
		
		if(!SN::MONITOR_PROCESS_SHOULD_TERMINATE)
		{
			PA_FreezeProcess(PA_GetCurrentProcessNumber());
		}
	}
	
#if VERSIONMAC
	[SN::listener release];
	SN::listener = nil;
#else
	UnregisterPowerSettingNotification(SN::notificationHandle);
	SN::notificationHandle = NULL;
	SetWindowLongPtr(SN::windowRef, GWLP_WNDPROC, (LONG_PTR)SN::originalWndProc);
#endif
	
	SN::MONITOR_PROCESS_ID = 0;
	
	PA_KillProcess();
}

void listenerLoopStart() {
    
	if(!SN::MONITOR_PROCESS_ID)
	{
		SN::MONITOR_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
																					 SN::MONITOR_PROCESS_STACK_SIZE,
																					 SN::MONITOR_PROCESS_NAME);
	}
}

void listenerLoopFinish() {
    
	if(SN::MONITOR_PROCESS_ID)
	{
		
		SN::MONITOR_PROCESS_SHOULD_TERMINATE = true;
		
		PA_YieldAbsolute();
		
		SN::LISTENER_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);
		SN::CALLBACK_METHOD_ID = 0;
		SN::CALLBACK_EVENT_IDS.clear();

		PA_UnfreezeProcess(SN::MONITOR_PROCESS_ID);
	}
}

void listenerLoopExecute() {
    
	SN::MONITOR_PROCESS_SHOULD_TERMINATE = false;
	
	PA_UnfreezeProcess(SN::MONITOR_PROCESS_ID);
}

void listenerLoopExecuteMethod() {
    
	std::vector<event_id_t>::iterator e = SN::CALLBACK_EVENT_IDS.begin();
	event_id_t event = (*e) - 1;
	
	if(SN::CALLBACK_METHOD_ID)
	{
		PA_Variable	params[1];
		params[0] = PA_CreateVariable(eVK_Longint);
		PA_SetLongintVariable(&params[0], event);

		SN::CALLBACK_EVENT_IDS.erase(e);
		
		PA_ExecuteMethodByID(SN::CALLBACK_METHOD_ID, params, 1);
		
		PA_ClearVariable(&params[0]);
	}else{
		PA_Variable	params[2];
		params[1] = PA_CreateVariable(eVK_Longint);
		PA_SetLongintVariable(&params[1], event);
		
		params[0] = PA_CreateVariable(eVK_Unistring);
		PA_Unistring method = PA_CreateUnistring((PA_Unichar *)SN::LISTENER_METHOD.getUTF16StringPtr());
		PA_SetStringVariable(&params[0], &method);
		
		SN::CALLBACK_EVENT_IDS.erase(e);
		
		PA_ExecuteCommandByID(1007, params, 2);
		
		PA_ClearVariable(&params[0]);
		PA_ClearVariable(&params[1]);
	}
	
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams);
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams) {
    
	switch(pProcNum)
	{
			
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
            
//        case kDeinitPlugin :
//            OnExit();
//            break;
			
// --- Notification

		case 1 :
			SN_Set_method(pResult, pParams);
			break;

		case 2 :
			SN_Get_method(pResult, pParams);
			break;

	}
}

// --------------------------------- Notification ---------------------------------

#pragma mark -

void SN_Set_method(sLONG_PTR *pResult, PackagePtr pParams) {
    
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	if(!IsProcessOnExit())
	{
		Param1.fromParamAtIndex(pParams, 1);
		
		if(!Param1.getUTF16Length())
		{
			//empty string passed
			returnValue.setIntValue(1);
			SN::CALLBACK_METHOD_ID = 0;
			SN::LISTENER_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);
			
			listenerLoopFinish();
			
		}else{
			
			method_id_t methodId = PA_GetMethodID((PA_Unichar *)Param1.getUTF16StringPtr());
			
			if(methodId)
			{
				returnValue.setIntValue(1);
				
				if(methodId != SN::CALLBACK_METHOD_ID)
				{
					SN::LISTENER_METHOD.setUTF16String(Param1.getUTF16StringPtr(), Param1.getUTF16Length());
					SN::CALLBACK_METHOD_ID = methodId;
					
					listenerLoopStart();
				}
			}else{
				returnValue.setIntValue(SYSTEM_NOTIFICATION_INVALID_METHOD_NAME_ERROR);
			}
		}
	}
	
	returnValue.setReturn(pResult);
}

void SN_Get_method(sLONG_PTR *pResult, PackagePtr pParams) {
    
	SN::LISTENER_METHOD.setReturn(pResult);
}
